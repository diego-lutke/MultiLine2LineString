import json
from shapely.geometry import LineString
from pyproj import Geod

geod = Geod(ellps='WGS84')

class Multi2Line:
    """
        Docstring generated by openAI completion API using code-davinci-002 model:
        It takes a MultiLineString and tries to convert it to a LineString.
        It does this by iterating over the sublines and trying to connect them.
        It does this by checking if the endpoints of the sublines are close enough to each other.
        If they are, it connects them and removes them from the list of sublines.
        If they aren't, it moves on to the next subline.\nIf it can't connect any of the sublines, it returns the original MultiLineString.
    """

    def __init__(self, threshold):
        self.threshold = threshold

    def run(self, multi_line):

        return self.multi_2_line(list(multi_line.geoms))

    def multi_2_line(self, sublines):

        # lengths = [geod.geometry_length(s) for s in sublines]
        # if len(sublines) <= 3 and self.threshold > max(lengths)/3:
        #     return [sublines[lengths.index(max(lengths))]]

        sublines = self._purge(sublines)

        if len(sublines) == 1:
            return sublines

        sublines = self._connect_touching(sublines)

        if len(sublines) == 1:
            return sublines

        used = []
        while True:

            if len(sublines) > 1 and sublines[0] in used:
                self.threshold = self.threshold*2
                return self.multi_2_line(sublines)

            if len(sublines) <= 1:
                return sublines

            used.append(sublines[0])

            ete = etb = bte = btb = False

            kb2e, mb2e, kb2b, mb2b, ke2b, me2b, ke2e, me2e = self._get_indexes(sublines)

            b2 = min(mb2e, mb2b)
            e2 = min(me2b, me2e)

            newline = []
            if b2 >= 0 and b2 < self.threshold:
                if b2 == mb2e:
                    newline.append(sublines[kb2e+1])
                    bte = True
                else:
                    newline.append(LineString(list(sublines[kb2b+1].coords)[::-1]))
                    btb = True

            newline.append(sublines[0])

            if e2 >= 0 and  e2 < self.threshold:
                if e2 == me2b:
                    if (bte and kb2e == ke2b) or (btb and kb2b == ke2b):
                        etb = False
                    else:
                        newline.append(sublines[ke2b+1])
                        etb = True
                else:
                    if (bte and kb2e == ke2e) or (btb and kb2b == ke2e):
                        ete = False
                    else:
                        newline.append(LineString(list(sublines[ke2e+1].coords)[::-1]))
                        ete = True

            toBePopped = [0]
            if bte:
                toBePopped.append(kb2e+1)
            if etb:
                toBePopped.append(ke2b+1)
            if btb:
                toBePopped.append(kb2b+1)
            if ete:
                toBePopped.append(ke2e+1)

            sublines = [s for i, s in enumerate(sublines) if i not in toBePopped]
            sublines += [self._linemerge(newline)]

            for i, c in enumerate(sublines):
                if len(c.boundary.geoms) < 2:
                    sublines.pop(i)

    def _purge(self, sublines):

        # purging identical pieces
        tr=[]
        for i, s in enumerate(sublines):
            if i not in tr:
                for j, l in enumerate(sublines):
                    if s == l and i != j:
                        tr.append(j)

        # purging short pieces
        opened_loops = []
        for i, s in enumerate(sublines):
            if i not in tr:
                if not (len(s.boundary.geoms) == 2 and geod.geometry_length(s) > self.threshold/2):
                    if len(s.boundary.geoms) == 0 and geod.geometry_length(s) > self.threshold/2:
                        # dealing with loops
                        opened_loops.append(self._open_loop(s))
                    tr.append(i)

        return opened_loops + [s for i, s in enumerate(sublines) if i not in tr]

    def _get_indexes(self, sublines):

        b2e = [self._distance(sublines[0].boundary.geoms[0], c.boundary.geoms[1])[2] for c in sublines[1:]]
        kb2e = b2e.index(min(b2e))

        b2b = [self._distance(sublines[0].boundary.geoms[0], c.boundary.geoms[0])[2] for c in sublines[1:]]
        kb2b = b2b.index(min(b2b))

        e2b = [self._distance(sublines[0].boundary.geoms[1], c.boundary.geoms[0])[2] for c in sublines[1:]]
        ke2b = e2b.index(min(e2b))

        e2e = [self._distance(sublines[0].boundary.geoms[1], c.boundary.geoms[1])[2] for c in sublines[1:]]
        ke2e = e2e.index(min(e2e))

        mb2e = min(b2e)
        mb2b = min(b2b)
        me2b = min(e2b)
        me2e = min(e2e)

        return kb2e, mb2e, kb2b, mb2b, ke2b, me2b, ke2e, me2e

    def _connect_touching(self, sublines):

        used = []
        while True:

            if len(sublines) <= 1 or sublines[0] in used:
                return sublines

            used.append(sublines[0])

            ete = etb = bte = btb = False

            kb2e, mb2e, kb2b, mb2b, ke2b, me2b, ke2e, me2e = self._get_indexes(sublines)

            newline = []
            if mb2e == 0:
                newline.append(sublines[kb2e+1])
                bte = True
            elif mb2b == 0:
                newline.append(LineString(list(sublines[kb2b+1].coords)[::-1]))
                btb = True
            newline.append(sublines[0])
            if me2b == 0:
                newline.append(sublines[ke2b+1])
                etb = True
            elif me2e == 0:
                newline.append(LineString(list(sublines[ke2e+1].coords)[::-1]))
                ete = True

            toBePopped = [0]
            if bte:
                toBePopped.append(kb2e+1)
            if etb:
                toBePopped.append(ke2b+1)
            if btb:
                toBePopped.append(kb2b+1)
            if ete:
                toBePopped.append(ke2e+1)

            sublines = [s for i,s in enumerate(sublines) if i not in toBePopped]
            sublines += [self._linemerge(newline)]

    def _open_loop(self, loop):
        return LineString(loop.coords[1:])

    def _linemerge(self, multi_line):
        outcoords = [list(i.coords) for i in multi_line]
        return LineString(self._custom_set([i for sublist in outcoords for i in sublist]))

    def _distance(self, p1, p2):
        return geod.inv(
            p1.coords[0][0],
            p1.coords[0][1],
            p2.coords[0][0],
            p2.coords[0][1]
        )

    def _custom_set(self, sequence):
        seen = set()
        return [x for x in sequence if not (x in seen or seen.add(x))]
